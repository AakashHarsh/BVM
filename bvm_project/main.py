from bvm.vm import BVM
from state.world_state import WorldState
from compilers.compiler import Compiler
from compilers.c_compiler import CCompiler
import os

def main():
    print("Starting BVM...")
    
    # Initialize world state and BVM
    world_state = WorldState()
    vm = BVM(world_state)
    
    # Detect contract language based on file extension
    contract_path = "contracts/math1"  # Base path without extension
    
    if os.path.exists(contract_path + ".py"):
        # Python contract
        print("\nDetected Python contract")
        with open(contract_path + ".py", "r") as f:
            contract_source = f.read()
        
        print("\nCompiling Python contract...")
        bytecode, storage_map = Compiler.compile(contract_source)
    
    elif os.path.exists(contract_path + ".c"):
        # C contract
        print("\nDetected C contract")
        with open(contract_path + ".c", "r") as f:
            contract_source = f.read()
        
        print("\nCompiling C contract...")
        bytecode = CCompiler.compile(contract_source)
        storage_map = "C contracts use direct storage access"  # Placeholder
    
    else:
        raise FileNotFoundError("No contract found in contracts/ directory")
    
    # To this:
    if isinstance(bytecode, tuple):  # C compiler returns (bytes, storage_map)
        bytecode, storage_map = bytecode
        print(f"\nGenerated bytecode: {bytecode.hex()}")
        print(f"Storage mapping: {storage_map}")
    else:  # Python compiler case
        print(f"\nGenerated bytecode: {bytecode.hex()}")
        print(f"Storage mapping: {storage_map}")
    
    # Execute the contract
    print("\nExecuting contract...")
    result = vm.execute(bytecode)
    
    print("\nExecution results:")
    print(f"Success: {result['success']}")
    print(f"Stack: {result['stack']}")
    print(f"Storage: {result['storage']}")

if __name__ == "__main__":
    main()
